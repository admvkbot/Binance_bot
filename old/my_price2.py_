#import telebot
#from telethon import TelegramClient, sync, events
import re
from binance import Client, ThreadedWebsocketManager, ThreadedDepthCacheManager
import sys
import os
import subprocess
import time
from datetime import datetime
#import math # math.floor() 
import xmltodict
import telegram_send
import mysql.connector as conn
from binance.enums import HistoricalKlinesType
import pathlib


coins = [""]
#coins_true = ["BZRX", "ARPA", "ANKR", "NEAR", "ZEN", "SFP", "GTC", "KEEP", "LUNA", "GALA", "LIT", "RSR", "MASK", "DOT", "TOMO", "BLZ", "ZEC", "ONE", "FTM", "CTK", "UNFI"]
#coins_true = ["BZRX", "ARPA", "ANKR", "ZEN", "SFP", "GTC", "KEEP", "LUNA", "GALA", "LIT", "RSR", "MASK", "TOMO", "BLZ", "ZEC", "ONE", "FTM", "CTK", "UNFI"]
coins_true = []
coins_black = ["ZEC", "RLC"]
percent = 2

orlov_path = "/home/run/orlovbot/"
config_xml = ''
with open(orlov_path+'main.xml', 'r') as f:
    config_xml = ''.join(list(map(str.strip, f.readlines())))
config = xmltodict.parse(config_xml)

api_key = config['config']['api-key']
api_secret = config['config']['api-secret']
proxy = config['config']['proxy']

api_key_2 = config['config']['api-key2']
api_secret_2 = config['config']['api-secret2']
proxy_2 = config['config']['proxy2']

path = "/var/www/html/"

def log_time(string, file=""):
    if file:
        f = open(file, "a+")
        f.write(str(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]) + ': ' + string + "\n")
        f.close()
    else:
        print(str(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]) + ': ' + string)
    
def set_pipe():
    global path
    f = open(path+'pipe6', 'w+')
    f.close() 

def check_pipe():
    global path
    return os.path.isfile(path+'pipe6')

def del_pipe():
    global path
    os.remove(path+'pipe6')

if check_pipe():
    log_time("Terminated")
    sys.exit()
        
set_pipe()

balance = 0 # размер позиции для лонга
balance_2 = 0 # размер позиции для лонга
min_balance = 50 # минимальный размер баланса, ниже которого повторная сделка не происходит (работает по линии balance_2)
short_balance = 0 # размер позиции для шорта
short_balance_2 = 0 # размер позиции для шорта

#summ = 60 #trade summ in dollars
leverage = 10
stop_percent = 0.2 #закрытие при цена после покупки + этот %
stop_percent_short = 1
short_timeout = 5*60 # задержка перед выставлением стоп-ордера шорт-позиции
trigger_percent = 1.6 # высота свечи в %. Выше этого значения лонг отменяется

# далее расписана сетка тейков
take_percent0 = 0.5
take_percent0_small = 0.4 # при возврате цены в течение отрезка времени
take_percent0_max = 0.5

take_percent1 = 1.5
take_percent_summ1 = 30
take_percent2 = 1.53
take_percent_summ2 = 30
take_percent3 = 1.55
take_percent_summ3 = 20
take_percent4 = 1.6
take_percent_summ4 = 20


take_type = 'true' # установка reduceOnly для тейков
if short_balance:
    take_type = 'false'

# далее расписана сетка шортов
short_percent1 = 5.3
short_percent_summ1 = 20
short_percent2 = 5.5
short_percent_summ2 = 20
short_percent3 = 5.7
short_percent_summ3 = 20
short_percent4 = 5.8
short_percent_summ4 = 20
short_percent5 = 5.9
short_percent_summ5 = 10
short_percent6 = 6
short_percent_summ6 = 10



stdout=path+'orlovbot6_out.log'
stderr=path+'orlovbot6_err.log'
str0 = 'http://' + str(proxy)
proxies = {
    'http': 'http://10.10.1.10:3128',
    'https': str0   
}
str0 = 'http://' + str(proxy_2)
proxies_2 = {
    'http': 'http://10.10.1.10:3128',
    'https': str0
}

#bot = telebot.TeleBot('1990712394:AAFK_R3HrJYGM76wV_1UltpQzKY1lig2_bA')
#@bot.message_handler(content_types=['text'])


log_time('START BOT')
"""
def get_text_messages(message):
    if message.text == "Привет":
        bot.send_message(message.from_user.id, "Привет, чем я могу тебе помочь?")
    elif message.text == "/help":
        bot.send_message(message.from_user.id, "Напиши привет")
    else:
        bot.send_message(message.from_user.id, "Я тебя не понимаю. Напиши /help.")
"""
if proxy:
    bclient = Client(api_key, api_secret, {'proxies': proxies})
else:
    bclient = Client(api_key, api_secret)

if proxy_2:
    bclient_2 = Client(api_key_2, api_secret_2, {'proxies': proxies_2})
else:
    bclient_2 = Client(api_key_2, api_secret_2)
    
###bclient_2 = bclient ###

def set_limit_order(db, order, num):
    global cursor
    #print (order)
    #sys.stdout.flush()
    """
    cursor.execute("SELECT * FROM limit_orders WHERE symbol='"+order['symbol']+"'")
    r = cursor.fetchall()
    db.commit()
    for order in r:
        num = num + order[8]
    """
    sql = "DELETE FROM limit_orders WHERE symbol='"+order['symbol']+"'"
    cursor.execute(sql)
    db.commit()
    sql = "INSERT INTO limit_orders (symbol, orderId, updateTime, price, origQty, side, status, number) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)"
    val = (order['symbol'], order['orderId'], order['updateTime'], order['price'], order['origQty'], order['side'], "new", num)
    cursor.execute(sql, val)
    db.commit()
    print(cursor.rowcount, "record inserted.")

def get_order_num(db, symbol):
    global cursor
    cursor.execute("SELECT * FROM limit_orders WHERE symbol='"+symbol+"'")
    r = cursor.fetchall()
    db.commit()
    num = 0
    for order in r:
        num = order[8]    
    return num

def buy(symbol, amount_2):
    try:            
        order_2 = bclient_2.futures_create_order ( 
            symbol=symbol,
            type='MARKET',
            side='SELL',
            quantity=amount_2,
            isIsolated='TRUE'
        )
        print(order_2)
        return order_2
    except:
        return 0

def buy2(symbol, amount_2):
    order_2 = bclient_2.futures_create_order ( 
        symbol=symbol,
        type='MARKET',
        side='SELL',
        quantity=amount_2,
        isIsolated='TRUE'
    )
    print(order_2)
    return order_2

#===============================================================================

def binance_work(symbol, base_price, last_price, j):

    def short(price, amount, amount_2):
        #print ("Long amount: " + amount)
        print ("Short order price: " + price)
        bclient_2.futures_create_order (
            symbol=symbol, 
            type='LIMIT', 
            timeInForce='GTC',
            price=price,  # The price at which you wish to buy/sell, float
            side='SELL',  # Direction ('BUY' / 'SELL'), string
            quantity=amount_2  # Number of coins you wish to buy / sell, float
        ) 
        """
        bclient.futures_create_order (
            symbol=symbol, 
            type='LIMIT', 
            timeInForce='GTC',
            price=price,  # The price at which you wish to buy/sell, float
            side='SELL',  # Direction ('BUY' / 'SELL'), string
            quantity=amount  # Number of coins you wish to buy / sell, float
        ) 
        """
    
    def stop_loss(stopPrice):
        print ("Stop order: " + stopPrice)
        order = bclient_2.futures_create_order (
            symbol = symbol, 
            side = 'BUY', 
            type = 'STOP_MARKET', 
            timeInForce = 'GTC', 
            stopPrice = stopPrice,
            closePosition = True
        )
        
    def take_buy(price, amount, amount_2, type):
        if float(amount_2):
            #try:
            #    bclient_2.futures_cancel_all_open_orders(symbol=symbol)
            #except:
            #    o=0
            try:
                return bclient_2.futures_create_order (
                    symbol=symbol, 
                    type='LIMIT', 
                    timeInForce='GTC',
                    price=price,  # The price at which you wish to buy/sell, float
                    side='BUY',  # Direction ('BUY' / 'SELL'), string
                    quantity=amount_2,  # Number of coins you wish to buy / sell, float
                    reduceOnly=type
                )
            except:
                return 0
        """
        if float(amount):
            bclient.futures_create_order (
                symbol=symbol, 
                type='LIMIT', 
                timeInForce='GTC',
                price=price,  # The price at which you wish to buy/sell, float
                side='BUY',  # Direction ('BUY' / 'SELL'), string
                quantity=amount,  # Number of coins you wish to buy / sell, float
                reduceOnly=type
            )  
        """    
        return 0

        # close start market
    def close_start_market(bclient_2, symbol, amount_2_start, tmp):
        if tmp != "693":
            time.sleep(6)
        try:
            bclient_2.futures_cancel_all_open_orders(symbol=symbol)
            bclient_2.futures_create_order (
                symbol=symbol, 
                side='BUY', 
                type='MARKET', 
                quantity=amount_2_start,
                reduceOnly='true'
            ) 
            log_time('Stop start market end '+tmp) 
        except:
            log_time('Stop start market ERROR '+tmp)             
        sys.stdout.flush()
        # close start market end


    global short_balance
    global coins
    global balance_2
    global balance
    global db
    global cursor
    global take_percent0
    global next_kline_status
    
    print ("------------------------------------------------------------------------------------------------")
    log_time('Start binance(): ' + symbol)
    log_time('Start binance(): ' + str(base_price) + ", last_price: " + str(last_price), orlov_path+"log/"+symbol)
    sys.stdout.flush()
    #base_price = float(base_price)
    """
    balance_raw = bclient.futures_account_balance()
    log_time('balance_raw received')
    balance = ''
    for item in balance_raw:
        if item['asset'] == 'USDT':
            balance = item['balance']
            print ('Balance: ' + balance)
    sys.stdout.flush()        
    if not balance:
        print ('Error getting balance')
        sys.exit()
    balance = float(balance)
    """
    """
    orders = bclient.get_all_orders(symbol=symbol, limit=1)
    print (orders)
    sys.exit()
    """   
    try:
        bclient_2.futures_change_leverage(symbol=symbol, leverage=leverage)
    except:
        time.sleep(1)
        try:
            bclient_2.futures_change_leverage(symbol=symbol, leverage=leverage)

        except:
            print ("futures_change_leverage error")
            sys.stdout.flush()
    #        coins.append(j)
            return 0
    """
    try:
        bclient_2.futures_change_margin_type(symbol=symbol, marginType='ISOLATED')
    except:
        o=0
    try:
        bclient.futures_change_margin_type(symbol=symbol, marginType='ISOLATED')
    except:
        o=0
    """

    #вычисление точности
    precision_price = 0
    if last_price < 0.1:
        precision_price = 5
    elif last_price < 1:
        precision_price = 4
    elif last_price < 10:
        precision_price = 3      
    elif last_price < 1000:
        precision_price = 2  

    ##balance = 42
    ##balance_2 = 42
    balance_n = balance / 9
    balance_2_n = balance_2 / 2.2
    # вычисление объёма монет
    amount = balance_n/last_price*leverage    
    amount_2 = balance_2_n/last_price*leverage
    amount_2_start = amount_2 / 5
    
    # определение необходимой точности
    precision = 0
    if amount < 1:
        precision = 4
    amount = "{:0.0{}f}".format(amount, precision)
    print ("Amount: "+ str(amount))
    precision = 0
    if amount_2 < 1:
        precision = 4
    amount_2 = "{:0.0{}f}".format(amount_2, precision)
    print ("Amount_2: "+ amount_2)
    amount_2_start = "{:0.0{}f}".format(amount_2_start, precision)
    print ("Amount_2_start: "+ amount_2_start)


    #### начальная покупка по триггеру
    order_2 = buy(symbol, amount_2_start)   ############################################## START BUYING
    info = bclient_2.futures_position_information(symbol=symbol)
    print ("~~~~")
    print (info)
    print ("~~~") 
    sys.stdout.flush()        
    last_amount_start = None
    last_price_start = None
    for inf in info:
        last_price_start = inf['entryPrice']                   
        last_amount_start = inf['positionAmt']
    if last_amount_start[0] == '-':
        amount_2_start = last_amount_start[1:]   
    else:
        amount_2_start = last_amount_start
            
    log_time('Real price (after START buy): ' + last_price_start + '; real START amount: ' + amount_2_start)
    last_price_start = float(last_price_start)
    stop_price_start = last_price_start + last_price_start/100*0.4
    limit_price_start = last_price_start - last_price_start/100*0.4

    stopPrice_start_str = "{:0.0{}f}".format(stop_price_start, precision_price)
    stop_loss(stopPrice_start_str)

    limit_price_start_str = "{:0.0{}f}".format(limit_price_start, precision_price)
    take_buy(limit_price_start_str, 0, amount_2_start, type)
    # end of start market 
    
    
    ##log_time('futures_change_leverage received')
    #bclient_2.futures_change_margin_type(symbol=symbol, marginType='ISOLATED')
    
    # получение начальной цены для работы
    #orderbook = bclient.get_ticker(symbol=symbol)
    #time.sleep(1)
    old_min = datetime.now().minute
    ##определение была ли цена близка к текущей за последние 15 минут
    klines = bclient_2.get_historical_klines(symbol, Client.KLINE_INTERVAL_1MINUTE, "40 min ago UTC", klines_type=HistoricalKlinesType.FUTURES)
    if not klines:
        log_time ("Kline 39 error")
        close_start_market(bclient_2, symbol, amount_2_start, "429")
        return 0
    ###orderbook = bclient_2.futures_orderbook_ticker(symbol=symbol)
   # print (orderbook)
   #sys.stdout.flush()
   # sys.exit()
    ##print("Price: "+ orderbook['askPrice'])
    ###last_price = float(orderbook['askPrice'])
    try:
        klines[39][4]
    except IndexError:
        print ("klines[39][4] error")
        close_start_market(bclient_2, symbol, amount_2_start, "441")
        return 2        
    last_price = float(klines[39][4])

    if not last_price:
        print ("last_price error")
        close_start_market(bclient_2, symbol, amount_2_start, "447")
        return 0
    log_time ('Base price: ' + str(base_price))
    #print ('Trigger percent: ' + str(trigger_percent))
    
    #last_price = float(last_price)
    #last_price = last_price + last_price/100*0.03
    print("Price: "+ str(last_price))
    sys.stdout.flush()
    # вычисление триггера для отмены лонга
    long_trigger = 0
    """
    if base_price:
        tmp = base_price + base_price/100*trigger_percent
        if last_price > tmp:
            long_trigger = 1
    print ("Long trigger: " + str(long_trigger))

    precision = 0
    if amount_2_first < 1:
        precision = 4
    amount_2_first = "{:0.0{}f}".format(amount_2_first, precision)
    print ("Amount_2_first: "+ str(amount_2_first))
    precision = 0
    if amount_2_second < 1:
        precision = 4
    amount_2_second = "{:0.0{}f}".format(amount_2_second, precision)
    print ("Amount_2_second: "+ str(amount_2_second))
    """
    #sys.stdout.flush()
    #sys.exit()
    num = 0
    if balance_2:   
        stop_price = last_price + last_price/100*stop_percent
        stop_price_0 = stop_price
        #if stop_price > 1:
        #if stop_price < 1:
        #    precision = 4
        max_time = 5
        # установка стоп-ордера
        time_start = time.time()
        time_end = time_start + max_time/2
        tmp_price = last_price
        old_price = last_price
        flag_return = 0
        for coin_true in coins_true:
            if coin_true == j and 1:
                flag_return = 1
        if not flag_return:
            f_price = last_price-last_price/100*0.4
            #l_price = last_price+last_price/100*(100/leverage*(100-leverage)*1.1)
            #telegram_send.send(messages=["Trigger: "+j+" ("+str(last_price)+"), limit: "+str(f_price)], conf="/etc/telegram-send.conf")
        while not flag_return and time_start < time_end and 0:# or old_price <= tmp_price:
            # получение цены монеты сразу после покупки
            orderbook = bclient_2.futures_orderbook_ticker(symbol=symbol)
            old_price = tmp_price
            tmp_price = orderbook['askPrice']
            log_time('TMP price ('+symbol+'): ' + str(tmp_price), orlov_path+"log/"+symbol)
            """
            tmp_price = float(tmp_price)
            tmp_stop_price = tmp_price - tmp_price/100*0.2
            if tmp_stop_price > stop_price_0:
                stop_price = tmp_stop_price
                #stop_price_0 = tmp_stop_price
                log_time('STOP price (sleep 2): ' + str(stop_price), orlov_path+"log/"+symbol)
            """
            time_start = time.time()
        log_time(j + '===========================================================', orlov_path+"log/"+symbol)
        #print('===========================================================')
        sys.stdout.flush()
        num = get_order_num(db, symbol)     
        if num > 4:
            telegram_send.send(messages=["Num > 4. Rejected 1.("+symbol+")"], conf="/etc/telegram-send.conf")
            time.sleep(1)
            close_start_market(bclient_2, symbol, amount_2_start, "521")
            return 1
   
        # покупка по рынку
        #print("base_price: "+str(base_price))
        log_time('Buy start')
        
        #sys.exit()
        long = 1
        my = 0 ###
        nomy = 0
        tmp_15 = 0
        tmp_30 = 0
        if (1):####
            now_min = datetime.now().minute
            jm = 39
            im = 34
            if old_min != now_min:
                jm = 38
                im = 33
            kline_in = float(klines[jm][1])
            check_kline_perc = (float(klines[jm][4])-kline_in)/kline_in*100
            min_check_perc = percent - 0.2
            if check_kline_perc < min_check_perc and not next_kline_status:
                log_time ("Rejected: short kline " + str(check_kline_perc) + ", last price:" + str(last_price))
                sys.stdout.flush()
                telegram_send.send(messages=["Rejected: "+symbol+" short kline " + str(check_kline_perc)], conf="/etc/telegram-send.conf")

                close_start_market(bclient_2, symbol, amount_2_start, "550")
               
                time.sleep(10)    
                return 0
            telegram_send.send(messages=["Trigger: "+j+" ("+str(last_price)+"), limit: "+str(f_price)], conf="/etc/telegram-send.conf")
            max_15_price = 0 #25 первых свечей
            max_30_price = 0 #все свечи возле последней
            z = 0
            for kline in klines:
                kline_max = float(kline[2])
                if z < im:
                    if kline_max > max_15_price:
                        max_15_price = kline_max
                if z < jm and z > im:
                    if kline_max > max_30_price:
                        max_30_price = kline_max
                z = z + 1
            print ('15: '+str(max_15_price)+'/'+str(last_price))
            tmp_15 = (1-max_15_price/last_price)*100
            log_time("Tmp 15 percent : "+str(tmp_15))
            tmp_30 = (1-max_30_price/last_price)*100
            log_time("Tmp 30 percent : "+str(tmp_30))
            if tmp_30 < 0.2:
                print (symbol+ " tmp_30 reject (40 sec)")
                close_start_market(bclient_2, symbol, amount_2_start, "573")
                time.sleep(60)
                return 0                


            try:
                orderbook = bclient_2.futures_orderbook_ticker(symbol=symbol)
            except:
                print ("Error futures_orderbook_ticker after 'tmp_30 reject (40 sec)'")
                close_start_market(bclient_2, symbol, amount_2_start, "582")
                return 0
            #tmp_price_start = float(orderbook['askPrice']) 
            tmp_price_start = last_price  
            #time.sleep(10)
            #orderbook = bclient_2.futures_orderbook_ticker(symbol=symbol)
            #tmp_price_now = float(orderbook['askPrice'])
            #perc_price = tmp_price_start - tmp_price_start/100*0.2

###            if tmp_price_now >= perc_price:
####            if 1:
            try:
                ###order_2 = buy(symbol, amount_2)  ###################################################### BUYING
                order_2 = 1
                if order_2:
                    my = my + 1
                    num = num + 1
                else:
                    g=0
                    print (symbol+ " buying error")
                    sys.stdout.flush()
                    time.sleep(60)
                    return 0
            except:
####            else:
                log_time("Order rejected by 10 sec")
                telegram_send.send(messages=["Order rejected by 10 sec"], conf="/etc/telegram-send.conf")
                sys.stdout.flush()
                #time.sleep(60)
                return 1
                
        #log_time('Buy end')
        #попытка докупить по более высокой цене
        
        time_start = int(time.time()*1000.0)
        time_start0 = time_start
        time_end = time_start + 6000
        buy_flag = 0
        """
        time.sleep(0.5)
        info = bclient_2.futures_position_information(symbol=symbol)          
        last_price = None
        for inf in info:
            last_price = inf['entryPrice'] 
        float_last_price = float(last_price)
        """
        float_last_price = last_price ###
        min_perc = 0.3
        max_perc = 0.4
        tmp_price_plus1 = float_last_price+float_last_price/100*min_perc # Процент дополнительного роста для срабатывания второй покупки
        tmp_price_plus2 = float_last_price+float_last_price/100*max_perc # Процент дополнительного роста для срабатывания второй увеличенной покупки
        additional_flag = 0
        plus = min_perc
        tmp_price_plus = tmp_price_plus1
        tmp_price_now = None

            
        while time_start < time_end and 1:
            orderbook = bclient_2.futures_orderbook_ticker(symbol=symbol)
            tmp_price_now = float(orderbook['askPrice'])
            #log_time (">>tmp_price_now: " + orderbook['askPrice'])
            time_test = int(time.time()*1000.0)
            
            tmp_time_5 = time_test - time_start0 
            """
            if tmp_price_now >= tmp_price_plus1 and tmp_time_5 < 3 and plus == min_perc:
                ###time_end = time_end + 3
                tmp_price_plus = tmp_price_plus2
                plus = max_perc
                log_time("PLUS: "+str(plus))
                sys.stdout.flush()
                continue  
            elif tmp_price_now >= tmp_price_plus:
            """
            if tmp_price_now > tmp_price_plus2:
                print (symbol+ " to the moon")
                telegram_send.send(messages=["To the moon"], conf="/etc/telegram-send.conf")
                #next_kline_status = time_test
                close_start_market(bclient_2, symbol, amount_2_start, "660")
                time.sleep(10)
                return 2
            if tmp_price_now > tmp_price_plus1 and tmp_time_5 < 1000:
                print (symbol+ " to the moon 2")
                telegram_send.send(messages=["To the moon 2"], conf="/etc/telegram-send.conf")
                #next_kline_status = time_test
                close_start_market(bclient_2, symbol, amount_2_start, "667")
                time.sleep(10)
                return 2
            """
            elif tmp_price_now >= tmp_price_plus:                
                if num > 4:
                    telegram_send.send(messages=["Num > 4. Rejected 2."], conf="/etc/telegram-send.conf")
                    sys.stdout.flush()
                    time.sleep(1)
                    return 1
                order_2 = buy(symbol, amount_2)  ###################################################### BUYING+
                if not order_2:
                    print (symbol+ " buying PLUS error !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    sys.stdout.flush()
                    time.sleep(60)
                    return 0
                num = num + 1
                buy_flag = 1
                print (">>> Additional buy: OK")
                additional_flag = 1
                telegram_send.send(messages=["Additional buy: "+str(plus)+"%"], conf="/etc/telegram-send.conf")
                break
            """
            time_start = int(time.time()*1000.0)        
        
        # close start market
        close_start_market(bclient_2, symbol, amount_2_start, "693")
        # close start market end
        
        tmp_price_now = float(orderbook['askPrice'])
        perc_price = tmp_price_start - tmp_price_start/100*min_perc
        if tmp_price_now >= perc_price and tmp_price_now < tmp_price_plus2:

            order_2 = buy(symbol, amount_2)  ###################################################### BUYING
            if not order_2:
                print (symbol+ " buying error !!!")
                sys.stdout.flush()
                time.sleep(60)
                return 0
            
            ff0 = (last_price-base_price)/base_price*100
            ff0 = "{:0.0{}f}".format(ff0, 2)
            ff = (tmp_price_now-base_price)/base_price*100
            ff = "{:0.0{}f}".format(ff, 2)
            l_t = tmp_price_now - tmp_price_now/100*take_percent0
            telegram_send.send(messages=["Buy price: "+ str(tmp_price_now)+ ", limit: "+ str(l_t) +", percent trigger: "+ff0+ "%"+ ", percent buy: "+ ff+ "%"], conf="/etc/telegram-send.conf")
        else:
            print ("Bad buy price: Start: "+ str(tmp_price_start)+ ", Now: "+str(tmp_price_now)+", MAX: "+ str(tmp_price_plus2))
            sys.stdout.flush()
            telegram_send.send(messages=["Bad buy price: Start: "+ str(tmp_price_start)+ ", Now: "+str(tmp_price_now)+", MAX: "+ str(tmp_price_plus2)], conf="/etc/telegram-send.conf")
            time.sleep(60)
            return 1
        """
        if not additional_flag and tmp_price_now >= tmp_price_plus1:
            if num > 4:
                telegram_send.send(messages=["Num > 4. Rejected 3."], conf="/etc/telegram-send.conf")
                sys.stdout.flush()
                time.sleep(1)
                return 1
            order_2 = buy(symbol, amount_2)  ###################################################### BUYING+
            if not order_2:
                print (symbol+ " buying PLUS error 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                sys.stdout.flush()
                time.sleep(60)
                return 0
            num = num + 1
            buy_flag = 1
            print (">>> Additional buy (last): OK")
            additional_flag = 1
            telegram_send.send(messages=["Additional buy (last): "], conf="/etc/telegram-send.conf")
        """
        
        # получение цены монеты сразу после покупки
        #orderbook = bclient_2.futures_orderbook_ticker(symbol=symbol)        
        #if not buy_flag:
        time.sleep(0.2)
        info = bclient_2.futures_position_information(symbol=symbol)
        #print ("+++")
        #print (info)
        #print ("+++") 
        #sys.stdout.flush()        
        last_amount = None
        last_price = None
        for inf in info:
            last_price = inf['entryPrice']                   
            last_amount = inf['positionAmt']
        if last_amount[0] == '-':
            amount_2 = last_amount[1:]   
        else:
            amount_2 = last_amount
            
        log_time('Real price (after buy): ' + last_price + '; real amount: ' + amount_2)
        last_price = float(last_price)
        
        if last_price < tmp_price_now:
            perc_last_price = (last_price - tmp_price_now)/last_price*100
            tmp_take_percent = take_percent0 - perc_last_price
            if tmp_take_percent < take_percent0_small:
                take_percent0 = take_percent0_small
            else:
                take_percent0 = tmp_take_percent
            

############################################## 

       
    stopPrice = last_price + last_price/100*0.9 ############### STOP ORDER
    stopPrice_str = "{:0.0{}f}".format(stopPrice, precision_price)
    stop_loss(stopPrice_str)        

 
    if not long_trigger and balance_2 and my:  
        amount = float(amount)
        amount_2 = float(amount_2)
        # установка сетки ордеров
        ### 1
        amount1 = amount#/100*take_percent_summ1
        amount1_2 = amount_2#/100*take_percent_summ1
        tmp_amount = amount1
        precision = 0
        if amount1 < 1:
            precision = 4
        amount1 = "{:0.0{}f}".format(amount1, precision)
        print ("Amount1: "+ str(amount1)) 
        tmp_amount_2 = amount1_2
        precision = 0
        if amount1_2 < 1:
            precision = 4
        amount1_2 = "{:0.0{}f}".format(amount1_2, precision)
        print ("Amount1_2: "+ str(amount1_2)) 
        #вычисление цены для тейка
        take_percent_tmp = take_percent0
        if tmp_15<1:
            take_percent_tmp = take_percent0_small
        """
        if not additional_flag:
            take_percent_tmp = take_percent0_max
        """
        take_price1 = last_price - last_price/100*take_percent_tmp
        take_price1 = "{:0.0{}f}".format(take_price1, precision_price)
        binance_percent = (last_price-base_price)/base_price*100
        ffb = "{:0.0{}f}".format(binance_percent, 2)
        print('Take price1: ' + take_price1)
        ffp = "{:0.0{}f}".format(take_percent_tmp, 2)
        telegram_send.send(messages=[ffp+'%, kline: '+ffb+'%'], conf="/etc/telegram-send.conf")
        
        #sys.stdout.flush()
        #time.sleep(1)
        #return 1
            
        sys.stdout.flush()    
        #установка тейк-профита
        ord = take_buy(take_price1, amount1, amount1_2, take_type)
        if not ord:
            print ("Take_buy error. Return 0.")
            sys.stdout.flush()
            return 0
        set_limit_order(db, ord, num)

        log_time('take1 end')
    #time.sleep(60)
    info = bclient_2.futures_position_information(symbol=symbol)          
    liq_price = None
    for inf in info:
        liq_price = inf['liquidationPrice'] 
    telegram_send.send(messages=["New position: "+j+" (Pos: "+str(last_price)+", Limit: "+str(take_price1)+", Liq:"+liq_price+")"], conf="/etc/telegram-send.conf")
    print ("---------------------------------------------------OK")
    return 1
    
"""
for h in coins:
    if os.path.isfile(orlov_path+"bot2/"+h):
        coins.remove(h)
        continue
for h in coins:
    if os.path.isfile(orlov_path+"bot2/"+h):
        coins.remove(h)
        continue
"""
def get_balance_from_file():
    global balance
    global balance_2
    f = open(orlov_path+'coins2/_balance', 'r+')
    str_balance = f.read()
    f.close()
    balance = float(str_balance)
    f = open(orlov_path+'coins2/_balance_2', 'r+')
    str_balance_2 = f.read()
    f.close()
    balance_2 = float(str_balance_2)

def set_balance_file():
    f = open(orlov_path+'coins2/_balance', 'w+')
    f.write(str(balance))
    f.close()    
    f = open(orlov_path+'coins2/_balance_2', 'w+')
    f.write(str(balance_2))
    f.close()    

def binance():
    global coins
    global balance
    global balance_2
    global coins_black
    global next_kline_status
    #log_time('S binance(): ' + symbol)
    #base_price = float(base_price)
 
    
    # получение начальной цен
    prices = None
    try:
        prices = bclient_2.futures_orderbook_ticker()
    except:
        log_time ("Getting prices error")
        time.sleep(60)
        return 0
    #print (prices)
    #sys.stdout.flush()
#    sys.exit()
    """
    BTC_price = 0
    for b in prices:
        tmp = b.get('symbol')
        ""
        time_coin = b.get('time')
        timestamp = time.time()
        t = timestamp - time_coin/1000
        print (t)
        sys.exit()
        ""
        if tmp == "BTCUSDT":
            BTC_price = float(b.get('askPrice'))
            break
    if not BTC_price:
        log_time("Error getting BTC price")
        sys.stdout.flush()
        time.sleep(1)
        return 1
    """    
    for i in prices:
        tmp = i.get('symbol')
        if re.search(r'USDT$', tmp):
        #for j in coins:
            #if os.path.isfile(orlov_path+"bot2/"+j):
            #    coins.remove(j)
            #    continue
            j = re.match(r'(\w+)USDT', tmp).group(1)
            jj_flag = 0
            for jj in coins_black:
                if j == jj:
                    jj_flag = 1
                    break
            if jj_flag:
                continue
                
            tmp2 = j + 'USDT'
            if tmp == tmp2:
                #log_time(j)
                #sys.stdout.flush()
                str0 = ''
                try:
                    f = open(orlov_path+'coins/'+j+'-old', 'r+')
                    str0 = f.read()
                    f.close()
                    p = pathlib.Path(orlov_path+'coins/'+j+'-old')
                    st = p.stat()
                    coin_file_date = st.st_mtime
                    tmp_time = time.time()-50
                    if coin_file_date < tmp_time:
                        #log_time (j + " устарел")
                        #sys.stdout.flush()
                        continue
                except:
                    #print (j)
                    #sys.stdout.flush()
                    continue ####
                    try:
                        f = open(orlov_path+'coins2/'+j+'-old', 'r+')
                        str0 = f.read()
                        f.close() 
                    except:
                        coins_black.append(j)
                if not str0 or str0 == '0':
                    continue
                old_price = float(str0)
                price = float(i.get('askPrice'))
                
                tmp = old_price + old_price/100*percent
                """
                f = open(orlov_path+'coins/BTC-old', 'r+')
                strBTC = f.read()
                f.close()
                if not strBTC:
                    log_time("BTC price error")
                    strBTC = str(BTC_price)
                old_BTC_price = float(strBTC)
                if not old_BTC_price:
                    time.sleep(20)
                    return 0
                """
                ##tmp_BTC = old_BTC_price + old_BTC_price/100*0.3
                #modul_BTC = abs(old_BTC_price - BTC_price)
                #tmp_modul = BTC_price/100*0.3 #==BTC
                #if price >= tmp:
                #    log_time("BTC modul: "+str(modul_BTC))
                ##tmp_error = old_price + old_price/100*(percent + 0.925)
                if price >= tmp:# and modul_BTC < tmp_modul:
                    #f = open(orlov_path+"coins/"+j+"2", 'w+')
                    #f.write("")
                    #f.close()                    
                    get_balance_from_file()
                    bin = binance_work(tmp2, old_price, price, j)
                    #telegram_send.send(messages=["----------------------------"], conf="/etc/telegram-send.conf")
                    if bin != 2:
                        time.sleep(60) ####
                        next_kline_status = 0
                    break
                """
                tmp = old_price + old_price/100*1.5
                if price >= tmp:
                    f = open(orlov_path+"coins/"+j, 'w+')
                    f.write("")
                    f.close()                    
                    continue
                """
                """
                if price >= tmp and modul_BTC >= tmp_modul:
                    log_time("BTC modul LARGE: "+str(modul_BTC))
               
                if price >= tmp_error and 0: # если цена выше допустимого проскальзывания, то только шорт
                    #balance = 0
                    f = open(orlov_path+"bot2/"+j, 'w+')
                    f.write(str(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]) + ': ' + str(old_price)+' - '+str(price)+"\n")
                    f.close()
                    log_time('price '+str(price)+' >= tmp_error ' + str(tmp_error) + '. Short only.')
                    binance_work(tmp2, old_price, price)
                    coins.remove(j)
                    b = 0
                    while balance_2 < min_balance and b < 60:
                        get_balance()
                        time.sleep(1)
                        b = b + 1
                    if b >= 60:
                        print ("Bot stopped normal")
                        del_pipe()
                        sys.exit()

                tmp2 = old_price + old_price/100*0.7
                if price >= tmp2 and price < tmp:
                    f = open(orlov_path+"bot2/"+j+'-07', 'w+')
                    f.write(str(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]) + ': ' + str(old_price)+' - '+str(price)+"\n")
                    f.close()                   
                    coins.remove(j)
                    break
                tmp3 = old_price + old_price/100*0.6
                if price >= tmp3 and price < tmp2:
                    f = open(orlov_path+"bot2/"+j+'-06', 'w+')
                    f.write(str(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]) + ': ' + str(old_price)+' - '+str(price)+"\n")
                    f.close() 
                    coins.remove(j)
                    break
                tmp4 = old_price + old_price/100*0.5
                if price >= tmp4 and price < tmp3:
                    f = open(orlov_path+"bot2/"+j+'-05', 'w+')
                    f.write(str(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]) + ': ' + str(old_price)+' - '+str(price)+"\n")
                    f.close()   
                    coins.remove(j)
                    break
                """
                
def get_balance():
    global balance
    global balance_2
    balance_raw = ''
    balance_raw_2 = ''
    try:
        balance_raw = bclient.futures_account_balance()
        balance_raw_2 = bclient_2.futures_account_balance()
    except:
        log_time('Balance getting error 1')
        flag = 0
        while not flag:
            try:
                balance_raw = bclient.futures_account_balance()
                balance_raw_2 = bclient_2.futures_account_balance()
                flag = 1
            except:
                log_time('Balance getting error 2')
                time.sleep(1)
    if not balance_raw or not balance_raw_2:
        print ("balance_raw error. Exit.")
        sys.exit()
    balance_str = ''
    for item in balance_raw:
        if item['asset'] == 'USDT':
            balance_str = item['balance']  
    if not balance_str:
        print ('Error getting balance')
        sys.exit()
    if not balance:
        balance = float(balance_str)
    print ("==============================================================================================")
    log_time('>> Balance: ' + balance_str)
    for item in balance_raw_2:
        if item['asset'] == 'USDT':
            balance_str_2 = item['balance']  
    if not balance_str_2:
        print ('Error getting balance 2')
        sys.exit()
    log_time('>> Balance 2: ' + balance_str_2)
    if not balance_2:
        balance_2 = float(balance_str_2)
    sys.stdout.flush()  
    set_balance_file()
    
def base_init(db):
    global cursor
    cursor.execute("""CREATE DATABASE IF NOT EXISTS orlovbot""")
    db.commit()
    cursor.execute("""USE orlovbot""")
    db.commit()
    cursor.execute("""CREATE TABLE IF NOT EXISTS limit_orders(
        id INT NOT NULL AUTO_INCREMENT,
        symbol CHAR(15) NOT NULL,
        orderId BIGINT UNSIGNED NOT NULL,
        updateTime BIGINT UNSIGNED NOT NULL,
        price TINYTEXT NOT NULL,
        origQty TINYTEXT NOT NULL,
        side TINYTEXT NOT NULL,
        status ENUM('new', 'renew', 'add', 'readd'),
        number INT UNSIGNED DEFAULT 0,
        PRIMARY KEY (id))""")
    db.commit()


# =======================================================================
        
db=conn.connect(host="localhost",user="root",password="connect")
cursor=db.cursor()
base_init(db)
#set_limit_order(db, "Test")

    
sys.stderr.flush()
with open(stderr, 'a+') as stderr:
    os.dup2(stderr.fileno(), sys.stderr.fileno())

sys.stdout.flush()
    ##print(4)
with open(stdout, 'a+') as stdout:
    os.dup2(stdout.fileno(), sys.stdout.fileno())

#bot.polling(none_stop=True, interval=0)

#client = TelegramClient('X100TradingBot', api_id, api_hash)
get_balance()
next_kline_status = 0
#@client.on(events.NewMessage(pattern=r'Покупаю\s\#|orlovbot'))
if 1:
#async def normal_handler(event):

    #out = subprocess.run(["ps", "aux"], stdout=subprocess.PIPE, text=True)
    #print (out.stdout)
    #sys.exit()
    #tmp = re.findall(r'python3 /home/run/orlovbot/main.py', out.stdout)
    #print (len(tmp))
    #for item in out.stdout:
    #print (out.stdout)

#    message = event.message.to_dict()['message']
#    log_time('MESSAGE RECEIVED')
    if 1:
    #if re.match(r'Покупаю\s\#(\w+)', message):
        #print(message)
        #symbol = re.match(r'Покупаю\s\#(\w+)', message).group(1)+'USDT'
        #print(symbol)
        stop = 0
        #telegram_send.send(messages=["Orlovbot started"], conf="/etc/telegram-send.conf")
        while check_pipe():  
            """
            klines = bclient_2.get_historical_klines("BZRXUSDT", Client.KLINE_INTERVAL_1MINUTE, "40 min ago UTC", klines_type=HistoricalKlinesType.FUTURES)
            print (klines[38][2])
            sys.stdout.flush()
            sys.exit()

            i = 0
            for kline in klines:
                kline_max = kline[2]
                log_time (str(i)+ " - "+kline_max)
                i = i + 1
            """
            if next_kline_status:
                kline_timestamp_now = time.time()
                tmp_t = next_kline_status + 10
                if kline_timestamp_now > tmp_t:
                    next_kline_status = 0
            binance()
            #sys.stdout.flush()
            #time.sleep(0.2)            
#        del_pipe()
        #await client.send_message('@Adm_S_R', symbol+" buy")
        """
    elif re.match(r'orlovbot', message):
        tmp = re.match(r'orlovbot\s(\w+)\s([\d\.]+)\s(\w+)', message)
        command = tmp.group(1)
        price = tmp.group(2) = 0
        market_type = tmp.group(3)
        if not command or not price or not market_type:
            print ('Orlovbot command error')
            sys.exit()
        print (command)
        print (price)
        print (market_type)
        sys.stdout.flush()
    
client.start()
client.run_until_disconnected()
"""
#193.142.42.167:32809




